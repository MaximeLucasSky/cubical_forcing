Require Import Template.monad_utils
        Template.Ast
        (* Template.AstUtils *)
        Template.TemplateMonad
        Template.LiftSubst.
        (* Template.Checker *)
        (* Template.Typing *)
        (* Template.Induction. *)

Require Import Translations.translation_utils.

Require Import Forcing.TemplateForcing
Forcing.translation_utils_bis.


Require Import List.



Import MonadNotation.
Import ListNotations.


Require Import BasicsMisc.
Require Import Hott_lemmas.
Require Import Simple_arithmetic.
Require Import Cubes.
Require Import Monotonicity.
Require Import Cartesian.



(** Check that category laws are definitional *)

Theorem compose_assoc {A B C D : nat}
           (f : A ~> B) (g : B ~> C) (h : C ~> D) :
  h √¥ (g √¥ f) = (h √¥ g) √¥ f.
Proof.
  reflexivity.
Qed.

(* For compose_id_* it is important that the underlying subset type with the second component in SProp
   was defined as a record with primitive projections *)
Theorem compose_id_right {A B : nat} (f : A ~> B) :
  f √¥ id = f.
Proof.
  reflexivity.
Qed.

Theorem compose_id_left {A B : nat} (f : A ~> B) :
  id √¥ f = f.
Proof.
  reflexivity.
Qed.


(** Definition of the forcing machinery *)

Definition ùêÇ_obj := nat.
Definition ùêÇ_hom := arrow.
Definition ùêÇ_id := @id.
Definition ùêÇ_comp := @compose.

Quote Definition q_ùêÇ_obj := nat.
Quote Definition q_ùêÇ_hom := @arrow.
Quote Definition q_ùêÇ_id := @id.
Quote Definition q_ùêÇ_comp := @compose.

Print q_ùêÇ_obj.

Definition ùêÇ : category :=
  mkCat q_ùêÇ_obj q_ùêÇ_hom q_ùêÇ_id q_ùêÇ_comp.

Definition Cat : category :=
  makeCatS "ùêÇ_obj" "arrow" "ùêÇ_id" "ùêÇ_comp".

Definition Cat' : category :=
  makeCatS "ùêÇ_obj" "ùêÇ_hom" "ùêÇ_id" "ùêÇ_comp".

Eval compute in Cat.
Eval compute in ùêÇ.
Eval compute in Cat'.



(************ Already defined elsewhere ********)
(*
Definition ForcingTranslation (cat : category) : Translation :=
  {| tsl_id := tsl_ident;
     tsl_tm := f_translate cat;
     tsl_ty := f_translate_type cat;
     tsl_ind := f_translate_ind cat
     (* tsl_context -> kername -> kername -> mutual_inductive_body *)
     (*             -> tsl_result (tsl_table * list mutual_inductive_body) *)
  |}.

Definition add_translation (ctx : tsl_context) (e : global_reference * term): tsl_context :=
  let (Œ£, E) := ctx in
  (Œ£, e :: E).
*)

(*********** Category changes here *********************)

Instance Cubical : Translation := ForcingTranslation ùêÇ.

(*******************************************************)

(* Define a type that, when recursively quoted, imports all we need *)
Definition pack := (arrow , @compose , @id).



Run TemplateProgram (prg <- tmQuoteRec pack ;;
                         tmDefinition "g_ctx" (fst prg)).

Print g_ctx.
Definition Œ£E : tsl_context := (Typing.reconstruct_global_context  g_ctx ,[]).




(** Definition of the interval *)

Run TemplateProgram (tImplementTC Œ£E "I_TC" "I" Type).
Next Obligation.
  exact (1 ~> p0).
Defined.


Definition initial_map (p : nat) : cube p -> cube 0.
  intro c. intros [a H]. destruct (pos_ge_0 a H).
Defined.



(*
   this proof uses funext to show that any two arrows with initial codomain must be
   equal. If necessary, it is possible to define a version that doesn't use it.
 *)

Definition initial_arrow (p : nat) : 0 ~> p := initial_map p.


Theorem initial_arrow_is_initial (p : nat) (Œ± : 0 ~> p) :
  Œ± = initial_arrow p.
Proof.
  apply funext. intro x. apply funext.
  intros [n H]. easy. 
Qed.

Definition I_end_map (p : nat) (e : bool) : cube p -> cube 1 :=
  (fun (_ : cube p) (_ : finset 1) => e).


Definition I_end (p : nat) (e : bool) : 1 ~> p := I_end_map p e.

Run TemplateProgram (tImplementTC I_TC "I0_TC" "I0" I).
Next Obligation.
  exact (I_end p false).
Defined.

Run TemplateProgram (tImplementTC I0_TC "I1_TC" "I1" I).
Next Obligation.
  exact (I_end p true).
Defined.






(** Imported inductives *)

(* We copy translated definitions of [eq] generated by the OCaml
   forcing plugin, because inducives are not supported yet by the
   template-coq forcing translation *)

Inductive eq·µó (p : ùêÇ_obj) (A : forall p0 : ùêÇ_obj, p ~> p0 -> forall p : ùêÇ_obj, p0 ~> p -> Type)
(x : forall (p0 : ùêÇ_obj) (Œ± : p ~> p0), A p0 Œ± p0 id) :
  (forall (p0 : ùêÇ_obj) (Œ± : p ~> p0), A p0 Œ± p0 id) -> Type :=
  eq_refl·µó : eq·µó p A x x.


(* This definition will fail if we leave the type of [A] implicit. *)
Definition eq_is_eq :
  forall p (A : forall x : ùêÇ_obj, (p ~> x) -> forall x1 : ùêÇ_obj, (x ~> x1) -> Type)
         (x y: forall p0 (f:p ~> p0), A p0 f p0 id),
    eq x y -> eq·µó p A x y. (* it even fails if i don't mention A as an explicit argument
                             here b/c of some mysterious reason *)
Proof.
  intros. rewrite H. apply eq_refl·µó.
Qed.
 

Run TemplateProgram (TC <- tAddExistingInd I1_TC "Coq.Init.Logic.eq" "eq·µó" ;;
                          tmDefinition "eq_TC" TC).

Inductive False·µó (p : ùêÇ_obj) := .

Run TemplateProgram (TC <- tAddExistingInd eq_TC "Coq.Init.Logic.False" "False·µó" ;;
                        tmDefinition "False_TC" TC).

Inductive or·µó (p : ùêÇ_obj) (A B : forall p0 : ùêÇ_obj, p ~> p0 -> forall p1 : ùêÇ_obj, p0 ~> p1 -> Prop) : Prop :=
    or_introl·µó : (forall (p0 : ùêÇ_obj) (Œ± : p ~> p0), A p0 Œ± p0 id) -> or·µó p A B
  | or_intror·µó : (forall (p0 : ùêÇ_obj) (Œ± : p ~> p0), B p0 Œ± p0 id) -> or·µó p A B.

Run TemplateProgram (TC <- tAddExistingInd False_TC "Coq.Init.Logic.or" "or·µó" ;;
                        tmDefinition "or_TC" TC).



Inductive and·µó (p : ùêÇ_obj) (A B : forall p0 : ùêÇ_obj, p ~> p0 -> forall p1 : ùêÇ_obj, p0 ~> p1 -> Prop) : Prop :=
    conj·µó : (forall (p0 : ùêÇ_obj) (Œ± : p ~> p0), A p0 Œ± p0 id) ->
            (forall (p0 : ùêÇ_obj) (Œ± : p ~> p0), B p0 Œ± p0 id) -> and·µó p A B.

Run TemplateProgram (TC <- tAddExistingInd or_TC "Coq.Init.Logic.and" "and·µó" ;;
                        tmDefinition "and_TC" TC).

Inductive sigT·µó (p : ùêÇ_obj)
          (A : forall p0, p ~> p0 -> forall p, p0 ~> p -> Type)
          (P : forall p0 (Œ± : p ~> p0),
              (forall p (Œ±0 : p0 ~> p), A p (Œ±0 √¥ Œ±) p id) ->
              forall p, p0 ~> p -> Type) : Type :=
  existT·µó : forall x : forall p0 (Œ± : p ~> p0), A p0 Œ± p0 id,
    (forall p0 (Œ± : p ~> p0), P p0 Œ± (fun (q : ùêÇ_obj) (Œ±0 : p0 ~> q) => x q (Œ±0 √¥ Œ±)) p0 id) ->
    sigT·µó p A P.


Run TemplateProgram (TC <- tAddExistingInd and_TC "Coq.Init.Specif.sigT" "sigT·µó" ;;
                        tmDefinition "sigT_TC" TC).

Inductive unit·µó (p : ùêÇ_obj) :=
  tt·µó : unit·µó p.

Run TemplateProgram (TC <- tAddExistingInd sigT_TC "Coq.Init.Datatypes.unit" "unit·µó" ;;
                        tmDefinition "unit_TC" TC).

Definition complete_TC := unit_TC.






(** Axiom 1 for I : connectedness *)

Definition zero_corner_map (p : nat) : cube 0 -> cube p.
  intros x d. exact false.
Defined.


Definition zero_corner (p : nat) : p ~> 0 := zero_corner_map p .

Definition face_map (p : nat) (b : bool) : S p ~> p := face_c (zero_finset p) b.

Definition degen_map (p : nat) : p ~> S p := degen_c (zero_finset p).

Theorem face_degen (p : nat) (b : bool) : face_map p b √¥ degen_map p = id.
Proof.
  apply funext.
  intro c. apply funext. intros [[| x] H].
  - compute. assert ((le_S_n 1 p (le_n_S 1 p H)) = H).
    apply Peano_dec.le_unique. rewrite H0. reflexivity.
  - compute. assert ((le_S_n (S (S x)) p (le_n_S (S (S x)) p H)) = H).
    apply Peano_dec.le_unique. rewrite H0. reflexivity.
Qed.

Definition side (p : nat) : cube (S p) -> bool.
  intro c. exact (c (zero_finset p)).
Defined.

Theorem side_face (p q : nat) (b : bool) Œ± (c : cube q) :
  side p ((Œ± √¥ face_map p b) c) = b.
Proof.
  now compute.
Qed.

Definition homotopy_to_zero (p : nat) (i : forall q : nat, p ~> q -> I·µó q q id)
  : forall q : nat, S p ~> q -> I·µó q q id.
  intros q Œ±.
  specialize (i q (Œ± √¥ (degen_map p))).
  pose (side p (Œ± (fun x => false))). destruct b. (* this is a travesty, not natural at all *)
  - exact i.
  - exact (I0·µó q).
Defined.

Theorem homotopy_restriction1 (p q : nat) (Œ± : p ~> q) (i : forall q : nat, p ~> q -> I·µó q q id)
  : i q Œ± = (homotopy_to_zero p i) q (Œ± √¥ face_map p true).
Proof.
  unfold homotopy_to_zero.
  rewrite side_face. change (Œ± √¥ face_map p true √¥ degen_map p) with (Œ± √¥ (face_map p true √¥ degen_map p)).
  rewrite (face_degen p true). reflexivity.
Qed.

Theorem homotopy_restriction2 (p q : nat) (Œ± : p ~> q) (i : forall q : nat, p ~> q -> I·µó q q id)
  : I0·µó q = (homotopy_to_zero p i) q (Œ± √¥ face_map p false).
Proof.
  unfold homotopy_to_zero.
  rewrite side_face. reflexivity.
Qed.

Theorem factorization (p : nat) : exists f, zero_corner (S p) = f √¥ face_map p false.
Proof.
  exists (zero_corner p). apply funext. intro c.
  apply funext. intros [[|x] H].
  - now compute.
  - now compute.
Qed.


Ltac simpl_comp :=
  repeat (match goal with
  | |- context [?Œ± √¥ ?n] =>
    change (Œ± √¥ n) with Œ±
  | |- context [?n √¥ ?Œ±] =>
    change (n √¥ Œ±) with Œ±
          end).

Ltac simpl_comp_hyp :=
  repeat (match goal with
          | H : context [?a √¥ ?n] |- _ => change (a √¥ n) with n in H
          | H : context [?a √¥ ?n] |- _ => change (a √¥ n) with a in H
          end).

(* Run TemplateProgram (tmLemma  "tt" (forall (œÜ : I -> Prop), ((forall i : I, œÜ i \/ (œÜ i -> False)) -> (forall i : I, œÜ i) \/ (forall i : I, œÜ i -> False)))). *)

Run TemplateProgram (tImplementTC complete_TC "ax1_TC" "ax1"
  (forall (œÜ : I -> Prop), ((forall i : I, œÜ i \/ (œÜ i -> False)) -> (forall i : I, œÜ i) \/ (forall i : I, œÜ i -> False)))).
Next Obligation.
  (* STRATEGY OUTLINE *)
  (* we start by applying H0 to decide whether œÜ(I0) is True or False. then we commit to prove that it is the
   same for every generalized point i. indeed, if œÜ(i) is different, we are able to build a generalized point
   that extends both I0(0, corner) and i(0, corner) therefore reaching a contradiction. *)
  rename H into H0.
  remember H0 as H1. clear HeqH1.
  specialize (H0 p id (fun p Œ± => I0·µó p)). destruct H0.
  - apply or_introl·µó. intros q Œ± i. simpl_comp.
    (* then apply H1 to the homotopy *)
    pose (homotopy_to_zero q i) as h.
    specialize (H1 (S q) (degen_map q √¥ Œ±) h). destruct H1.
    + assert ((fun (p2 : nat) (a1 : q ~> p2) => i p2 (a1 √¥ id)) = (fun (p2 : nat) (Œ±1 : q ~> p2) => (homotopy_to_zero q i) p2 (Œ±1 √¥ face_map q true))).
      apply funext_dep. intro r. apply funext_dep. intro Œ≥.
      rewrite homotopy_restriction1. reflexivity.  unfold ùêÇ_comp. unfold ùêÇ_id. unfold ùêÇ_obj.
      rewrite H1. clear H1.
      change (homotopy_to_zero q i) with h. simpl_comp. 
      specialize (H0 q (face_map q true)).
      simpl_comp_hyp.
      assert (Œ± = face_map q true √¥ degen_map q √¥ Œ±).
      rewrite face_degen. reflexivity.
      rewrite H1. apply H0.
    + specialize (H0 0 (zero_corner (S q))). assert (False·µó 0).
      apply H0. intros q' Œ≤.
      pose proof (factorization q) as [Œ≥ H1].
      simpl_comp.
      match goal with
      | |- œÜ _ _ ?t _ _ => assert (t = (fun (p4 : nat) (Œ±3 : q' ~> p4) => I0·µó p4))
      end.
      apply funext_dep. intro r. apply funext_dep. intro Œ¥.
      rewrite H1. unfold h.
      rewrite (homotopy_restriction2 q' r Œ¥ (fun q0 a => I0·µó q0)). reflexivity.
      rewrite H2. clear H2.
      specialize (H q' (Œ≤ √¥ zero_corner (S q) √¥ degen_map q √¥ Œ±)). apply H.
      inversion H1.
  - apply or_intror·µó. intros q Œ± i H2.
    pose (homotopy_to_zero q i) as h.
    specialize (H1 (S q) (degen_map q √¥ Œ±) h). destruct H1.
    + clear H2. unshelve eapply H. exact Œ±. intros q' Œ≤.
      specialize (H0 q' (Œ≤ √¥ face_map q false)).
       unfold ùêÇ_comp in H0. unfold ùêÇ_id in H0. unfold ùêÇ_obj in H0.
      simpl_comp_hyp.
      change (Œ≤ √¥ face_map q false √¥ (degen_map q √¥ Œ±)) with (Œ≤ √¥ (face_map q false √¥ degen_map q) √¥ Œ±) in H0. 
      rewrite face_degen in H0. 
      assert ((fun (p2 : nat) (Œ±1 : q' ~> p2) => h p2 (Œ±1 √¥ (Œ≤ √¥ face_map q false))) = (fun (p2 : nat) (Œ±1 : q' ~> p2) => I0·µó p2)).
      apply funext_dep. intro r. apply funext_dep. intro Œ¥. 
      unfold h.
      unshelve erewrite homotopy_restriction2. exact q'. exact Œ¥. exact (fun q0 a => I0·µó q0). reflexivity.
      rewrite H1 in H0. exact H0.
    + clear H. apply H0 with (Œ±0 := face_map q true). intros q' Œ≤.
      specialize (H2 q' Œ≤). simpl_comp_hyp.  unfold ùêÇ_comp in H2. unfold ùêÇ_id in H2. unfold ùêÇ_obj in H2. simpl_comp.
      assert (Œ≤ √¥ id √¥ Œ± = Œ≤ √¥ face_map q true √¥ degen_map q √¥ Œ±). unshelve erewrite <- face_degen. exact true.  reflexivity. simpl_comp_hyp.
      rewrite H in H2. clear H.  unfold ùêÇ_comp. unfold ùêÇ_id. unfold ùêÇ_obj.
      change (id √¥ Œ≤ √¥ id √¥ (id √¥ face_map q true √¥ id) √¥ id √¥ (degen_map q √¥ Œ±) √¥ id) with (Œ≤ √¥ face_map q true √¥ degen_map q √¥ Œ±).
      assert ((fun (p4 : nat) (Œ±3 : q' ~> p4) => h p4 (Œ±3 √¥ (Œ≤ √¥ face_map q true))) = (fun (p3 : nat) (Œ±2 : q' ~> p3) => i p3 (id √¥ Œ±2 √¥ Œ≤ √¥ id))).
      apply funext_dep. intro r. apply funext_dep. intro Œ¥. simpl_comp.
      change (Œ¥ √¥ (Œ≤ √¥ face_map q true)) with (Œ¥ √¥ Œ≤ √¥ face_map q true).
      unfold h. rewrite <- homotopy_restriction1. reflexivity. simpl_comp.  rewrite H.
      exact H2.
Defined.



(** Axiom 1 for J *)

(* This should actually be SProp, but we cannot translate SProp as of now.
 So we will need some propositional extensionality i guess *)

Run TemplateProgram (tImplementTC ax1_TC "natp_TC" "natp" (Prop -> Prop)).
Next Obligation.
  rename X into S. rename Œ± into Œ±0.
  exact (forall (p1 : nat) (Œ±1 : p0 ~> p1), S p0 Œ±0 p1 Œ±1 <-> S p1 (Œ±1 √¥ Œ±0) p1 id).
Defined.


Run TemplateProgram (tImplementTC ax1_TC "nati_TC" "nati" (I -> Prop)).
Next Obligation.
  rename X into i. rename Œ± into Œ±0. 
  exact (forall (p1 : nat) (Œ±1 : p0 ~> p1), Œ±1 √¥ (i p0 Œ±0) = i p1 (Œ±1 √¥ Œ±0)).
Defined.

Print nati·µó_obligation_1.

  


Print I·µó_obligation_1.

(* Run TemplateProgram (tImplementTC nati_TC "nati_TC+" "natiTrivial" (forall i : I, nati i)). *)
(* Next Obligation. Print I·µó_obligation_1. *)
(*  unfold nati·µó. unfold nati·µó_obligation_1. intros. simpl_comp. unfold I·µó in i. unfold I·µó_obligation_1 in i. *)

    

Arguments existT {_ _} _.

Notation "'Œ£' x .. y , P" := (sigT (fun x => .. (sigT (fun y => P)) .. ))
                            (at level 200, x binder, y binder, right associativity).
Notation "( x ; .. ; y ; z )" := (existT x (.. (existT y z) ..)).

Definition J := Œ£ (i : I), nati i.



Run TemplateProgram (TC1 <- Translate nati_TC "J" ;;
                         tmDefinition "J_TC" TC1).



Run TemplateProgram (tImplementTC J_TC "natj_TC" "natj"
                                  (J -> Prop)).
Next Obligation.
  rename X into j.
  unshelve refine (forall (p1 : nat) (Œ±1 : p ~> p1), j p1 Œ±1 = _).
  specialize (j p id).
  unfold J·µó. unshelve refine (existT·µó _ _ _ _ _).
  - intros. destruct j as [i0 nati0]. (* exact (i0 p2 (Œ±0 √¥ Œ±1)). *) exact (Œ±0 √¥ i0 p1 (Œ±1)). (* or other possibility? *)
  - intros. destruct j as [i0 nati0]. unfold nati·µó. unfold nati·µó_obligation_1. unfold nati·µó in nati0. unfold nati·µó_obligation_1 in nati0.
    intros. simpl_comp.
    (* specialize (nati0 p2 (Œ±0 √¥ Œ±1) p3 Œ±2). simpl_comp_hyp. exact nati0. *) reflexivity.
Defined.


Check transport.
Lemma dep_eq (A B: Type) (P : A -> Type) (F : forall a : A, P a -> B) {x y : A} {Px : P x} {Py : P y}
      (p : x = y)
      (q : transport P p Px = Py) : F x Px = F y Py.
Proof.
  destruct p. simpl in q. destruct q. reflexivity.
Defined.

(* Run TemplateProgram (tImplementTC natj_TC "natj_all_TC" "natj_all" *)
(*                                   (forall j : J, natj j)). *)
(* Next Obligation. *)
(*   unfold natj·µó, natj·µó_obligation_1. *)
(*   intros p1 Œ±1. simpl_comp. *)
(*   remember (j p1 Œ±1) as jp1. *)
(*   destruct jp1. *)
(*   unshelve refine (dep_eq _ _ _ _ _ _). *)
(*   apply funext_dep. intro p2. apply funext_dep. intro Œ±0. *)
(*   remember (j p id) as jp. destruct jp. apply funext. intro x1. *)
(*   unfold nati·µó, nati·µó_obligation_1 in *.  *)
  

Run TemplateProgram (tImplementTC natj_TC "mnati_TC" "make_nati"
                                  (I -> J)).
Next Obligation.
  rename X into i. unfold J·µó. unshelve eapply existT·µó.
  - intros p0 Œ±. exact (Œ± √¥ i p id).
  - intros. unfold nati·µó. unfold nati·µó_obligation_1. intros. reflexivity.
Defined.


Run TemplateProgram (tImplementTC mnati_TC "fnati_TC" "forget_nati"
                                  (J -> I)).
Next Obligation.
  specialize (X p id). unfold J·µó in X. destruct X. exact (x p id).
Defined.


  


Run TemplateProgram (tImplementTC fnati_TC "eq_nati_TC" "eq_nati"
                                  (forall i : I, forget_nati (make_nati i) = i)).
Next Obligation.
  apply eq_is_eq. apply funext_dep. intro p0. apply funext_dep. intro Œ±.
  unfold forget_nati·µó. unfold forget_nati·µó_obligation_1. unfold make_nati·µó. unfold make_nati·µó_obligation_1. simpl_comp. reflexivity.
Defined.


Run TemplateProgram (tImplementTC eq_nati_TC "eq2_nati_TC" "eq2_nati"
                                  (forall i : J, make_nati (forget_nati i) = i)).
Next Obligation.
  apply eq_is_eq. apply funext_dep. intro p0. apply funext_dep. intro Œ±.
  unfold forget_nati·µó. unfold forget_nati·µó_obligation_1. unfold make_nati·µó. unfold make_nati·µó_obligation_1. simpl. simpl_comp.
  destruct (i p0 Œ±).
  unfold nati·µó in n.  unfold nati·µó_obligation_1 in n.
  assert ((fun (p1 : nat) (Œ±0 : p0 ~> p1) => Œ±0 √¥ x p0 id) = x).
  - apply funext_dep. intro p1. apply funext_dep. intro Œ±1. exact (n p0 id p1 Œ±1).
  - revert n. rewrite <- H. intro n. apply f_equal.
    apply funext_dep. intro p1.
    apply funext_dep. intro Œ±0.
    apply funext_dep. intro p2.
    apply funext_dep. intro Œ±1. pose (n p1 Œ±0 p2 Œ±1) as H1.
    simpl_comp_hyp.
    (** True if nati in SProp(?) **)
Admitted.


Run TemplateProgram (tImplementTC eq_nati_TC "proj_nati_TC" "proj_nati"
                                  (forall i : J, natj i -> nati (forget_nati i))).
Next Obligation.
  intro. intro.  unfold forget_nati·µó. unfold forget_nati·µó_obligation_1.
   unfold make_nati·µó. unfold make_nati·µó_obligation_1. simpl_comp.
  simpl_comp.
  pose (i p id) as H1.
  assert (H1 = i p id). reflexivity.
  change (i p id) with H1. destruct H1.
  pose (i p1 Œ±1) as H2.
  assert (H2 = i p1 Œ±1). reflexivity.
  change (i p1 Œ±1) with H2. destruct H2.
  unfold nati·µó in n , n0. unfold nati·µó_obligation_1 in n, n0.
  pose (n p id p1 Œ±1) as Hn0. simpl_comp_hyp. rewrite Hn0.
  
  unfold make_nati·µó in H, H0. unfold make_nati·µó_obligation_1.
  unfold forget_nati·µó. unfold forget_nati·µó_obligation_1. unfold make_nati·µó. unfold make_nati·µó_obligation_1. simpl_comp.
  unfold natj·µó in H. unfold natj·µó_obligation_1 in H.
  specialize (H p id p1 Œ±1). simpl_comp_hyp. rewrite H in H1.
  assert (x0 = (fun (p2 : nat) (Œ±0 : p1 ~> p2) => match i p id with
                                          | existT·µó _ _ _ i0 _ => Œ±0 √¥ i0 p1 Œ±1
                                          end)).
  exact (TFUtils.ap (fun u : sigT·µó _ _ _ => match u with
                                         |existT·µó _ _ _ x _ => x end)  H1).
  rewrite H2. simpl. rewrite <- H0. reflexivity.
Defined.


Axiom funext_dep_refl : forall {A : Type} (P : A -> Type) (f : forall a : A, P a), funext_dep f f (fun x => eq_refl) = eq_refl.

Run TemplateProgram (tImplementTC proj_nati_TC "make_natj_TC" "make_natj"
                                  (forall i : I, nati i -> natj (make_nati i))).
Next Obligation.
  unfold natj·µó.
  unfold natj·µó_obligation_1.
  intros.
  unfold make_nati·µó. unfold make_nati·µó_obligation_1.
  unfold nati·µó in H. unfold nati·µó_obligation_1 in H.
  unshelve refine (dep_eq _ _ _ _ _ _).
  - apply funext_dep. intro p0. apply funext_dep. intro Œ±. simpl_comp.
    specialize (H _ id _ Œ±1). simpl_comp_hyp. rewrite H. reflexivity.
  - simpl. simpl_comp. apply funext_dep. intro x. apply funext_dep. intro.
    apply funext_dep. intro. apply funext_dep. intro. unfold eq_ind_r.
    remember (H p id p1 Œ±1) as H'. simpl_comp_hyp. clear HeqH'.  destruct H'. simpl.
    assert ((funext_dep (fun (p0 : nat) (Œ± : p1 ~> p0) => Œ± √¥ (Œ±1 √¥ i p id)) (fun (p2 : nat) (Œ±0 : p1 ~> p2) => Œ±0 √¥ (Œ±1 √¥ i p id))
       (fun p0 : nat =>
          funext_dep (fun Œ± : p1 ~> p0 => Œ± √¥ (Œ±1 √¥ i p id)) (fun Œ±0 : p1 ~> p0 => Œ±0 √¥ (Œ±1 √¥ i p id)) (fun Œ± : p1 ~> p0 => eq_refl))) = eq_refl).
    { assert ((fun p0 : nat => funext_dep (fun Œ± : p1 ~> p0 => Œ± √¥ (Œ±1 √¥ i p id)) (fun Œ±0 : p1 ~> p0 => Œ±0 √¥ (Œ±1 √¥ i p id)) (fun Œ± : p1 ~> p0 => eq_refl))
              = fun p0 => eq_refl).
      { apply funext_dep. intro. apply funext_dep_refl. }
      rewrite H0. apply funext_dep_refl. }
    rewrite H0. simpl. reflexivity.
Defined.
    
    
   

Run TemplateProgram (tImplementTC make_natj_TC "J0_TC" "J0" J).
Next Obligation.
  unshelve refine (existT·µó _ _ _ _ _).
  - intros p0 Œ±0. exact (I_end p0 false).
  - intros p0 Œ±0 p1 Œ±1. reflexivity.
Defined.

Run TemplateProgram (tImplementTC J0_TC "J1_TC" "J1" J).
Next Obligation.
  unshelve refine (existT·µó _ _ _ _ _).
  - intros p0 Œ±0. exact (I_end p0 true).
  - intros p0 Œ±0 p1 Œ±1.  reflexivity.
Defined.

Definition homotopy_to_zero' (p : nat) (i : forall q : nat, p ~> q -> J·µó q q id)
  : forall q : nat, S p ~> q -> J·µó q q id.
  intros p0 Œ±0. unshelve refine (existT·µó _ _ _ _ _).
  - intros q Œ±1. pose (Œ±1 √¥ Œ±0) as Œ±.
    specialize (i p0 (Œ±0 √¥ (degen_map p))). destruct i as [i Hi].
    intro c. pose (Œ± c) as c'. pose (side p c') as s. destruct s.
    * exact ((i p0 id) (Œ±1 c)).
    * exact (fun _ => false).
  - intros p1 Œ±1 p2 Œ±2. 
    destruct (i p0 (Œ±0 √¥ degen_map p)) as [i' Hi]. reflexivity.
Defined.

Definition projT1' {p : nat} {A : forall p0 : nat, p ~> p0 -> forall p1 : nat, p0 ~> p1 -> Type}
           {B : forall (p0 : nat) (Œ± : p ~> p0), (forall (p1 : nat) (Œ±0 : p0 ~> p1), A p1 (Œ±0 √¥ Œ±) p1 id) -> forall p1 : nat, p0 ~> p1 -> Type}
  : sigT·µó p A B -> forall (p0 : nat) (Œ± : p ~> p0), A p0 Œ± p0 id.
  intros [x y]. exact x.
Defined.

Theorem J_eq {p : nat} (a b : J·µó p p id)
  : projT1' a = projT1' b -> a = b.
Proof.
  destruct a. destruct b. simpl.
  intro H. destruct H.
  assert (n = n0). apply proof_irr. rewrite H. reflexivity.
Qed.

Theorem homotopy_restriction1' (p q : nat) (Œ± : p ~> q) (i : forall q : nat, p ~> q -> J·µó q q id)
  : i q Œ± = (homotopy_to_zero' p i) q (Œ± √¥ face_map p true).
Proof.
  assert (projT1' (i q Œ±) = projT1' (homotopy_to_zero' p i q (Œ± √¥ face_map p true))).
  { apply funext_dep. intro p0. apply funext. intro Œ±0.
    unfold homotopy_to_zero'.
    Opaque side. Opaque degen_c. Opaque face_map. simpl.
    change (Œ± √¥ face_map p true √¥ degen_map p) with (Œ± √¥ (face_map p true √¥ degen_map p)).
    rewrite face_degen. change (Œ± √¥ id) with Œ±.
    destruct (i q Œ±) as [j Hj]. simpl.
    apply funext. intro c.
    change (Œ±0 √¥ (Œ± √¥ face_map p true)) with ((Œ±0 √¥ Œ± √¥ (face_map p true))).
    rewrite side_face.
    specialize (Hj q id). unfold nati·µó in Hj. unfold nati·µó_obligation_1 in Hj.
    change (j p0 Œ±0) with (j p0 (Œ±0 √¥ id √¥ id √¥ id)).
    rewrite <- (Hj p0 Œ±0). reflexivity. }
  apply J_eq. exact H.
Defined.



Theorem homotopy_restriction2' (p q : nat) (Œ± : p ~> q) (i : forall q : nat, p ~> q -> J·µó q q id)
  : J0·µó q = (homotopy_to_zero' p i) q (Œ± √¥ face_map p false).
Proof.
  assert (projT1' (J0·µó q) = projT1' (homotopy_to_zero' p i q (Œ± √¥ face_map p false))).
  { apply funext_dep. intro p0. apply funext. intro Œ±0.
    unfold homotopy_to_zero'.
    Opaque side. Opaque degen_c. Opaque face_map. simpl.
    change (Œ± √¥ face_map p false √¥ degen_map p) with (Œ± √¥ (face_map p false √¥ degen_map p)).
    rewrite face_degen. change (Œ± √¥ id) with Œ±.
    destruct (i q Œ±) as [j Hj].
    apply funext. intro c.
    change (Œ±0 √¥ (Œ± √¥ (face_map p false))) with ((Œ±0 √¥ Œ± √¥ (face_map p false))).
    rewrite side_face. now compute. }
  apply J_eq. exact H.
Defined.


Run TemplateProgram (tImplementTC J1_TC "ax1'_TC" "ax1'"
  (forall (œÜ : J -> Prop), ((forall i : J, œÜ i \/ (œÜ i -> False)) -> (forall i : J, œÜ i) \/ (forall i : J, œÜ i -> False)))).
Next Obligation.
  (* STRATEGY OUTLINE *)
  (* we start by applying H0 to decide whether œÜ(I0) is True or False. then we commit to prove that it is the
   same for every generalized point i. indeed, if œÜ(i) is different, we are able to build a generalized point
   that extends both I0(0, corner) and i(0, corner) therefore reaching a contradiction. *)
  rename H into H0.
  remember H0 as H1. clear HeqH1.
  specialize (H0 p id (fun p Œ± => J0·µó p)). destruct H0.
  - apply or_introl·µó. intros q Œ± i.
    (* then apply H1 to the homotopy *)
    pose (homotopy_to_zero' q i) as h.
    specialize (H1 (S q) (degen_map q √¥ Œ±) h). destruct H1.
    + assert ((fun (p2 : nat) (Œ±1 : q ~> p2) => i p2 (Œ±1 √¥ id)) = (fun (p2 : nat) (Œ±1 : q ~> p2) => (homotopy_to_zero' q i) p2 (Œ±1 √¥ face_map q true))).
      apply funext_dep. intro r. apply funext_dep. intro Œ≥.
      rewrite homotopy_restriction1'. reflexivity.
      rewrite H1. clear H1.
      change (homotopy_to_zero' q i) with h. change (id √¥ id √¥ (id √¥ Œ± √¥ id) √¥ id √¥ id) with Œ±.
      specialize (H0 q (face_map q true)).
      change (id √¥ (id √¥ face_map q true √¥ id) √¥ id √¥ (degen_map q √¥ Œ±) √¥ id √¥ id) with (face_map q true √¥ degen_map q √¥ Œ±) in H0.
      assert (Œ± = face_map q true √¥ degen_map q √¥ Œ±).
      rewrite face_degen. reflexivity.
      rewrite H1. apply H0.
    + specialize (H0 0 (zero_corner (S q))). assert (False·µó 0).
      apply H0. intros q' Œ≤.
      pose proof (factorization q) as [Œ≥ H1]. simpl_comp.
      assert ((fun (p4 : nat) (Œ±3 : q' ~> p4) => h p4 (Œ±3 √¥ (Œ≤ √¥ zero_corner (S q)))) = (fun (p4 : nat) (Œ±3 : q' ~> p4) => J0·µó p4)).
      apply funext_dep. intro r. apply funext_dep. intro Œ¥.
      rewrite H1. unfold h. change (Œ¥ √¥ (Œ≤ √¥ (Œ≥ √¥ face_map q false))) with ((Œ¥ √¥ Œ≤ √¥ Œ≥) √¥ face_map q false).
      erewrite homotopy_restriction2'. reflexivity.
      rewrite H2. clear H2.
      change (Œ≤ √¥ (zero_corner (S q) √¥ (degen_map q √¥ Œ±))) with (Œ≤ √¥ zero_corner (S q) √¥ degen_map q √¥ Œ±).
      specialize (H q' (Œ≤ √¥ zero_corner (S q) √¥ degen_map q √¥ Œ±)). apply H.
      inversion H1.
  - apply or_intror·µó. intros q Œ± i H2.
    pose (homotopy_to_zero' q i) as h.
    specialize (H1 (S q) (degen_map q √¥ Œ±) h). destruct H1.
    + clear H2. eapply H. intros q' Œ≤.
      simpl_comp. specialize (H0 q' (Œ≤ √¥ face_map q false)). simpl_comp.
      change (id √¥ (id √¥ (Œ≤ √¥ face_map q false) √¥ id) √¥ id √¥ (degen_map q √¥ Œ±) √¥ id) with (Œ≤ √¥ (face_map q false √¥ degen_map q) √¥ Œ±) in H0.
      simpl_comp_hyp. change (Œ≤ √¥ face_map q false √¥ (degen_map q √¥ Œ±)) with (Œ≤ √¥ (face_map q false √¥ degen_map q) √¥ Œ±) in H0.
      rewrite face_degen in H0.
      assert ((fun (p2 : nat) (Œ±1 : q' ~> p2) => h p2 (Œ±1 √¥ (Œ≤ √¥ face_map q false))) = (fun (p2 : nat) (Œ±1 : q' ~> p2) => J0·µó p2)).
      apply funext_dep. intro r. apply funext_dep. intro Œ¥. unfold h.
      change (Œ¥ √¥ (Œ≤ √¥ face_map q false)) with (Œ¥ √¥ Œ≤ √¥ face_map q false).
      erewrite homotopy_restriction2'. reflexivity.
      rewrite H1 in H0. exact H0.
    + clear H. apply H0 with (Œ±0 := face_map q true). intros q' Œ≤.
      specialize (H2 q' Œ≤). simpl_comp. simpl_comp_hyp.
      change (Œ≤ √¥ Œ±) with (Œ≤ √¥ id √¥ Œ±) in H2.
      assert (Œ≤ √¥ id √¥ Œ± = Œ≤ √¥ face_map q true √¥ degen_map q √¥ Œ±). erewrite <- face_degen. reflexivity.
      rewrite H in H2. clear H.
      change (Œ≤ √¥ (face_map q true √¥ (degen_map q √¥ Œ±))) with (Œ≤ √¥ face_map q true √¥ degen_map q √¥ Œ±).
      assert ((fun (p4 : nat) (Œ±3 : q' ~> p4) => h p4 (Œ±3 √¥ (Œ≤ √¥ face_map q true))) = (fun (p3 : nat) (Œ±2 : q' ~> p3) => i p3 (Œ±2 √¥ Œ≤))).
      apply funext_dep. intro r. apply funext_dep. intro Œ¥.
      unfold h.
      change (Œ¥ √¥ (Œ≤ √¥ face_map q true)) with (Œ¥ √¥ Œ≤ √¥ face_map q true).
      rewrite <- homotopy_restriction1'. reflexivity. rewrite H.
      exact H2.
Defined.





(** Axiom 2 : distinct end points *)

Definition lowest_corner (p : nat) : cube p.
  intro. exact false.
Defined.

Run TemplateProgram (tImplementTC ax1'_TC "ax2_TC" "ax2" (I0 = I1 -> False)).
Next Obligation.
  specialize (H p id). inversion H.
  assert (I0·µó p = I1·µó p).
  change (I0·µó p) with ((fun (p1 : nat) (_ : p ~> p1) => I0·µó p1) p id). rewrite H1. reflexivity.
  assert (I_end_map p false = I_end_map p true). 
  change (I_end_map p false) with ((I0·µó p)). rewrite H0. reflexivity.
  assert (false = true). 
  change false with (I_end_map p false (lowest_corner p) (zero_finset 0)). rewrite H2. reflexivity.
  inversion H3.
Defined.




(** Connection algebra structure *)

Definition join_arrow {p : nat} (f : 1 + 1 ~> p) : 1 ~> p.
  pose (join_c (zero_finset 0)) as g.
  exact  ( g o f ). 
Defined.

Definition meet_arrow {p : nat} (f : 1 + 1 ~> p) : 1 ~> p.
  pose (meet_c (zero_finset 0)) as g.
  exact ( g o f).
Defined.

Run TemplateProgram (tImplementTC ax2_TC "join_TC" "join_i" (I -> I -> I)).
Next Obligation.
  rename X into i1. rename X0 into i2.
  specialize (i1 p id). specialize (i2 p id).
  pose (fuse_arrows (i1, i2)). exact (join_arrow a).
Defined.

Run TemplateProgram (tImplementTC join_TC "meet_TC" "meet_i" (I -> I -> I)).
Next Obligation.
  rename X into i1. rename X0 into i2.
  specialize (i1 p id). specialize (i2 p id).
  pose (fuse_arrows (i1, i2)). exact (meet_arrow a).
Defined.

Notation "a ‚äì b" := (meet_i a b) (at level 65, left associativity).
Notation "a ‚äî b" := (join_i a b) (at level 65, left associativity).


(** Axiom 3 : computational behaviour of ‚äì *)

Run TemplateProgram (tImplementTC meet_TC "ax3_TC" "ax3"
                                  ( forall i : I, I0 ‚äì i = I0 /\ i ‚äì I0 = I0 /\ I1 ‚äì i = i /\ i ‚äì I1 = i )).
Next Obligation.
  repeat (split; intros).
  - apply eq_is_eq.
    apply funext_dep. intro p1. apply funext_dep. intro Œ±0.
    unfold meet_i·µó. unfold meet_i·µó_obligation_1.
    unfold I0·µó. unfold I0·µó_obligation_1.
    apply funext. intro d. apply funext. intro k. destruct k.
    unfold meet_arrow. simpl. unfold fcompose. simpl. destruct x.
    + reflexivity.
    + easy.
  - apply eq_is_eq.
    apply funext_dep. intro p2. apply funext_dep. intro Œ±1.
    unfold meet_i·µó. unfold meet_i·µó_obligation_1.
    unfold I0·µó. unfold I0·µó_obligation_1.
    apply funext. intro d. apply funext. intro k. destruct k.
    unfold meet_arrow. simpl. unfold fcompose. simpl. destruct x.
    + simpl. unfold I_end. unfold I_end_map.
      apply Bool.andb_false_r.
    + easy.
  - apply eq_is_eq.
    apply funext_dep. intro p3. apply funext_dep. intro Œ±2.
    unfold meet_i·µó. unfold meet_i·µó_obligation_1.
    unfold I1·µó. unfold I1·µó_obligation_1.
    apply funext. intro d. apply funext. intro k. destruct k.
    unfold meet_arrow. simpl. unfold fcompose. simpl. destruct x.
    + simpl. simpl_comp. f_equal. f_equal. unfold lt in l.
      apply Peano_dec.le_unique.
    + easy.
  - apply eq_is_eq.
    apply funext_dep. intro p3. apply funext_dep. intro Œ±2.
    unfold meet_i·µó. unfold meet_i·µó_obligation_1.
    unfold I1·µó. unfold I1·µó_obligation_1.
    apply funext. intro d. apply funext. intro k. destruct k.
    unfold meet_arrow. simpl. unfold fcompose. simpl. destruct x.
    + simpl. simpl_comp. unfold I_end. unfold I_end_map.
      rewrite Bool.andb_true_r. repeat f_equal. apply Peano_dec.le_unique.
    + easy.
Defined.





(** Axiom 4 : computational behaviour of ‚äî *)

Run TemplateProgram (tImplementTC ax3_TC "ax4_1_TC" "ax4_1" (forall i : I, I0 ‚äî i = i)).
Next Obligation.
  unfold join_i·µó. unfold join_i·µó_obligation_1. 
  assert ((fun (p0 : nat) (Œ± : p ~> p0) => join_arrow (fuse_arrows (I0·µó p0, i p0 (id √¥ (Œ± √¥ (id √¥ id) √¥ id))))) =  (fun (p0 : nat) (Œ± : p ~> p0) => i p0 (Œ± √¥ (id √¥ id) √¥ id))).
  apply funext_dep. intro q. apply funext_dep. intro Œ±.
  apply funext. intro c.
  apply funext. intros [x px].
  destruct x.
  - simpl_comp.
    replace (join_arrow (fuse_arrows (I0·µó q, i q Œ±))) with (join_c (zero_finset 0) o (fuse_arrows (I0·µó q, i q Œ±))).
    + Transparent fuse_cube_maps. compute.
      match goal with
      | [ |- _ _ (exist _ 0 ?XX) = _ _ (exist _ 0 px) ] => erewrite (Peano_dec.le_unique _ _ XX px)
      end. reflexivity.
    + unfold join_arrow. reflexivity.
  - assert False. easy. inversion H.
  - rewrite H. apply eq_refl·µó.
Defined.




Run TemplateProgram (tImplementTC ax4_1_TC "ax4_TC" "ax4"
                                  (forall i : I, I0 ‚äî i = i /\ i ‚äî I0 = i /\ I1 ‚äî i = I1 /\ i ‚äî I1 = I1)).
Next Obligation.
  repeat (split; intros); apply eq_is_eq.
  - apply funext_dep. intro p1. apply funext_dep. intro Œ±0.
    unfold join_i·µó. unfold join_i·µó_obligation_1.
    unfold I0·µó. unfold I0·µó_obligation_1.
    apply funext. intro d. apply funext. intro k. destruct k.
    unfold join_arrow. simpl. unfold fcompose. simpl. destruct x.
    + unfold  le_lt_dec.
      simpl. repeat f_equal. apply Peano_dec.le_unique.
    + easy.
  - apply funext_dep. intro p2. apply funext_dep. intro Œ±1.
    unfold join_i·µó. unfold join_i·µó_obligation_1.
    unfold I0·µó. unfold I0·µó_obligation_1.
    apply funext. intro d. apply funext. intro k. destruct k.
    unfold join_arrow. simpl. unfold fcompose. simpl. destruct x.
    + unfold le_lt_dec. simpl. 
      unfold I_end. unfold I_end_map.
      rewrite Bool.orb_false_r.
      repeat f_equal. apply Peano_dec.le_unique.
    + easy.
  - apply funext_dep. intro p3. apply funext_dep. intro Œ±2.
    unfold join_i·µó. unfold join_i·µó_obligation_1.
    unfold I1·µó. unfold I1·µó_obligation_1.
    apply funext. intro d. apply funext. intro k. destruct k.
    unfold join_arrow. simpl. unfold fcompose. simpl. destruct x.
    + unfold le_lt_dec. simpl. reflexivity.
    + easy.
  - apply funext_dep. intro p3. apply funext_dep. intro Œ±2.
    unfold join_i·µó. unfold join_i·µó_obligation_1.
    unfold I1·µó. unfold I1·µó_obligation_1.
    apply funext. intro d. apply funext. intro k. destruct k.
    unfold join_arrow. simpl. unfold fcompose. simpl. destruct x.
    + simpl. unfold I_end. unfold I_end_map.
      rewrite Bool.orb_true_r. reflexivity.
    + easy.
Defined.
    